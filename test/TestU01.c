/*
gcc -I../include -Wall -g -O2 -c -o TestU01.o TestU01.c
gcc -Wall -g -O2  -o TestU01 ../src/libcsprng_la-havege.o ../src/libcsprng_la-nist_ctr_drbg_mod.o ../src/libcsprng_la-csprng.o TestU01.o  -lssl -ltestu01
gcc -Wall -g -O2  -o TestU01 ../src/havege.o ../src/nist_ctr_drbg_mod.o ../src/csprng.o TestU01.o  -lssl -ltestu01

32-bit

gcc -m32 -I../src -Wall -g -O2 -c -o TestU01.o TestU01.c
gcc -m32 -Wall -g -O2  -o TestU01 ../src/havege.o ../src/nist_ctr_drbg_mod.o ../src/csprng.o TestU01.o /home/jirka/C/64-bit/2011-Nov-19-TestU01/TestU01-1.2.3/./testu01/.libs/libtestu01.so -lssl

LD_LIBRARY_PATH=/home/jirka/C/64-bit/2011-Nov-19-TestU01/TestU01-1.2.3/./testu01/.libs /home/jirka/C/64-bit/2011-Nov-21-Ermine/ErmineLightTrial.i386 -v -K --ld_assume_kernel=2.6.15 TestU01 --output=TestU01_AllCrush_32
*/

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <unif01.h>
#include <bbattery.h>

#include "csprng/csprng.h"

typedef struct {
  rng_buf_type output_buf;      //Output Buffer
  csprng_state_type state;      //State of the generator
  int size;                     //How many bytes are generated by one iteration (units: bytes)
} csprng_output_type;


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  csprng_init_buf
 *  Description:  
 * =====================================================================================
 */
int
csprng_init_out ( csprng_output_type* data, int size )
{
  int error;

  data->size = size;

  error = csprng_init(&data->state, 0, 0, 7, 1);
  if ( error ) {
    fprintf(stderr, "Error: csprng_init has returned %d\n",error);
    return(error);
  }


  data->output_buf.buf	= (unsigned char*) malloc ( size + sizeof(unsigned int) );
  if (  data->output_buf.buf==NULL ) {
    fprintf ( stderr, "\nDynamic memory allocation failed\n" );
    return (1);
  }
  data->output_buf.total_size = size + sizeof(unsigned int);
  data->output_buf.valid_data_size = 0;
  data->output_buf.buf_start = data->output_buf.buf;
  return 0;
}		/* -----  end of function csprng_init_buf  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  csprng_destroy_buf
 *  Description:  
 * =====================================================================================
 */
int
csprng_destroy_out ( csprng_output_type* data )
{
  int error;

  free (data->output_buf.buf);
  data->output_buf.buf	= NULL;
  data->output_buf.buf_start = NULL;
  data->output_buf.total_size = 0;
  data->output_buf.valid_data_size = 0;

  error = csprng_destroy(&data->state);
  if ( error ) {
    fprintf(stderr, "Error: csprng_destroy has returned %d\n",error);
    return(error);
  }

  return 0;

}		/* -----  end of function csprng_destroy_buf  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  csprng_fill_buf
 *  Description:  
 * =====================================================================================
 */
int
csprng_fill_out ( csprng_output_type* data )
{
  int error;

  // 1. Rewind buffer
  if ( data->output_buf.valid_data_size ) {
    memmove(data->output_buf.buf, data->output_buf.buf_start, data->output_buf.valid_data_size);
  }
  data->output_buf.buf_start =  data->output_buf.buf;

  // 2. Fill buffer
  while ( data->output_buf.valid_data_size + data->size <= data->output_buf.total_size ) {
    //memcpy(data->output_buf.buf_start + data->output_buf.valid_data_size, output, data->size);
    error = csprng_generate(&data->state, data->output_buf.buf_start + data->output_buf.valid_data_size, data->size);
    if ( error ) {
      fprintf(stderr, "Error: csprng_generate  has returned %d\n",error);
      return(error);
    }
    data->output_buf.valid_data_size += data->size;
  }
  return 0;
}		/* -----  end of function csprng_fill_buf  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  csprng_get_unsigned_int_buf
 *  Description:  
 * =====================================================================================
 */
unsigned int
csprng_get_unsigned_int ( csprng_output_type* data )
{
  unsigned char* temp;
  const static unsigned int bytes_needed=4;   //TestU01 requires exactly 32bits
  unsigned int result;

  if ( bytes_needed > data->output_buf.valid_data_size ) {
    csprng_fill_out (data);
    if ( bytes_needed > data->output_buf.valid_data_size ) {
      fprintf ( stderr, "\nBuffer does not support such big data sizes\n" );
      exit (EXIT_FAILURE);
    }
  }

  data->output_buf.valid_data_size -= bytes_needed;
  temp = data->output_buf.buf_start;
  data->output_buf.buf_start = data->output_buf.buf_start + bytes_needed;

  result = ((unsigned int) (*temp) ) << 24;
  temp += 1;
  result |= ((unsigned int) (*temp) ) << 16;
  temp += 1;
  result |= ((unsigned int) (*temp) ) << 8;
  temp += 1;
  result |= ((unsigned int) (*temp) );

  //dump_hex_byte_string (temp-3, sizeof(unsigned int), "Big endian number:\t");
  //dump_hex_byte_string ((unsigned char *)&result, sizeof(unsigned int), "32-bit integer:\t");

  return(result);

}		/* -----  end of function csprng_get_unsigned_int_buf  ----- */


static csprng_output_type internal_status;

unsigned int csprng_get_unsigned_int_void ( ) {
  return csprng_get_unsigned_int(&internal_status);
}

int main (int argc, char **argv) 
{
   int sflag = 0;
   int nflag = 0;
   int bflag = 0;
   int c;

   opterr = 0;

   while ((c = getopt (argc, argv, "snb")) != -1)
     switch (c)
       {
       case 'b':
         bflag = 1;
         break;
       case 's':
         sflag = 1;
         break;
       case 'n':
         nflag = 1;
         break;
       case '?':
         if (isprint (optopt))
           fprintf (stderr, "Unknown option `-%c'.\n", optopt);
         else
           fprintf (stderr,
                    "Unknown option character `\\x%x'.\n",
                    optopt);
         return 1;
       default:
         abort ();
       }


  unif01_Gen *gen;
  csprng_init_out (&internal_status, 512*16);

  gen = unif01_CreateExternGenBits ("Havege with CTR_DRBG", csprng_get_unsigned_int_void);

  if (sflag) bbattery_SmallCrush (gen);
  if (nflag) bbattery_Crush (gen);
  if (bflag) bbattery_BigCrush (gen);

  unif01_DeleteExternGenBits (gen);

  csprng_destroy_out (&internal_status);


  return 0;
}

